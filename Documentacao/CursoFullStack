Curso Full Stack e Spring - Algaworks --------------------------------------------------[24/08/2018]

	Modulo 1 - Introdução ao REST:

		Aula 1.1 - Introdução ao curso:

			- Angular, REST e SpringBoot.

			- JavaScript, TypeScript, Html e Css.
			- O projeto exemplo começa com o desenvolvimento Back-End, serviço RESTFull.

			- A parte de apresentação sera Front-End, Angular.

		Aula 1.2 - Suporte:

		Aula 1.3 -  O que é SOFEA:

			- SOFEA (Service-Oriented Front-End Architecture).

			- Remover toda lógica de apresentação do servidor e levar para o cliente.

			- No inicio da conexão faz o download do Html e Css para o cliente, e depois so tráfega dados, como
			padrão JSON.

			- Desenvolvimento Assíncrono do front-end e back-end.

			- Fica mais facil escalabilidade e interoperabilidade (vários clientes).

			- Melhora a experiência do usuário.

		Aula 1.4 - O que é REST:
		
			- Uma forma de integrar sistemas.

			- Front-end -> REST -> Back-end.

			- REST é uma arquitetura com alguns principios que permitem integrar sistemas.

			- REST-Full é uma implementação da arquitetura REST.	

			- API-REST (Aplicattion Program Interface) expõem serviços para aplicações externas.

		Aula 1.5 - Projeto Exemplo:
		
			- Um sistema de lançamento financeiro com débito e crédito.

		Aula 1.6. Ambiente de desenvolvimento REST:

			- SpringBoot, SpringMvc, SpringSecurity e SpringJPA.

			- STS (IDE baseada no Eclipse).

			- Postman (testar as Api-Rest).

			- Pode testar as requisições independente do Front-End.

			- Banco de Dados MySql.
			
------------------------------------------------------------------------------------------[28/08/2018]

		Aula 1.7. Testando APIs com Postman:

			- Utilizando Postman para testar os end-points do Back-End.

			- Utilizar o site www.mocky.io para simular acesso ao Back-End. Vai gerar uma url que depois você coloca no Postman para
			verificar a resposta.

		Aula 1.8. Introdução ao protocolo HTTP:
		
			- Protocolo Http baseado em uma requisição(Request) e obtem uma resposta(Response).	

			- O Http tem um verbo que pode ser GET,POST,PUT,DELETE....

			- O Http tem uma Url para identificar para onde vou fazer a chamada.

			- No Http posso pasar Headers(informações a mais) e Parâmetros(filtros).

			- O Http tem respostas com código(200, 404,500...) identificando o que aconteceu com a requisição recebida.

			- A resposta tem Headers(Content-type)tipo de conteúdo da resposta, tem o corpo da resposta(body) os dados.

	Modulo 2 - Fundamentos do REST:

		Aula 2.1. O que é um recurso?

			- Um recurso tem que ter uma maneira de ser identificado (id por exemplo), uma Uri(uma url completa, com parte que serve 
			para identificar um recurso específico).

		Aula 2.2. Representações de um recurso:
		
			- A mesma Url me traz o mesmo recursos com representações diferentes, que pode ser uma Imagem, Json ou Xml.

			- O recurso pode ter várias representações.	

------------------------------------------------------------------------------------------[29/08/2018]

		Aula 2.3. Modelo de maturidade Richardson - Nível 0:

			- Martin Fowler descreveu o modelo de Richardson para o REST, indo do nível 0 ao 3.

			- No nível 0 não é REST:

				* Http somente como transporte.

				* A solicitação é feita com um único serviço e o código de resposta é a mesma independente de sucesso ou não.

				* Se aproxima de chamar um método remoto.

		Aula 2.4. Modelo de maturidade Richardson - Nível 1:
			
			- O nível 1 ainda não é REST:

				* Já é utilizado o conceito de recurso, passando um identificador.		

				* O código de resposta é unico independete do sucesso ou não.

		Aula 2.5. Modelo de maturidade Richardson - Nível 2:
		
			- O nível 2 já pode ser considerado REST:

				* Já é utilizado os verbos Http (post,get,put....).

				* Posso passar na requisição parâmetros e filtros (query string).

				* A resposta da requisição já modifica o código de retorno.

		Aula 2.6. Modelo de maturidade Richardson - Nível 3	:

			- O nível 3 é um REST completo:

				* Utiliza os verbos Http (post,get,put....).

				* A resposta da requisição já modifica o código de retorno. 

				* Posso passar na requisição parâmetros e filtros (query string).

				* A resposta traz mais informações como a URI para acessar o recurso.

		Aula 2.7. HATEOAS:

			- Hypertexto As Engine Of Application State - HATEOAS.

			- A resposta traz informações adicionais sobre utilizar a URI, para novas ações. Essas informações
			podem ser influenciadas de acordo com regras de négocios.

			- A resposta HATEOS pode ser utilizado para o Front-End ter um determinado comportamento.

------------------------------------------------------------------------------------------[10/09/2018]		
		
		Aula 2.8. Segurança de APIs REST:

			- API privada ou pública.

			- HTTPS o http está criptografado.

			- Autenticação (quem é você ) e Autorização (áreas que você pode acessar).

			- Tipos de segurança para o Https Basic, Digest, Certificados e Tokens.

			- OAuth foi criado para fazer autorização. Você é autorizado por outro sites que não o seu.

		Aula 2.9. Idempotência:
		
			- Um método é considerado idempontente se o resultado produzido por ele é o mesmo independente
			do número de vezes que for executado.

	Modulo 3 - Primeiras consultas e cadastros na API:

		Aula 3.1. Criando o projeto da API:

			- Utilizando o STS para iniciar o projeto, através do Spring Boot. Selecionar as dependência da Web, Jpa e Devtools.

			- Vou utilizar a versão 2.0.4 do spring boot.

		Aula 3.2. Conectando ao MySQL:
		
			- Configuração do Banco de Dados MySQL no arquivo /algamoney-api/src/main/resources/application.properties.

			- Utilizar WorkBench para gerenciar o MySql.

		Aula 3.3. Migração de dados com Flyway:
		
			- Não utilizar a geração de tabelas no banco com Hibernate. Em ambiente de produção deve ser utilizado uma 
			ferramenta de migração.

			- Vamos utilizar a ferramenta de migração Flyway.

			- Vamos criar scripts para o banco de dados de forma incremental, com isso garantindo rastreabilidade nas 
			versões do banco.
				
------------------------------------------------------------------------------------------[11/09/2018]		

		Aula 3.4. Consultando primeiro recurso com GET:

			- A tabela Categoria está populada, então vamos implementar o GET para retornar uma lista de categórias.

			- Criar uma interface de Categoria que extende a JpaRepository (framework spring), que tem vários métodos 
			de manipulação de banco de dados.

			- Criar a classe que vai expor o recursos de Categoria. Um controlador rest.

		Aula 3.5. Coleção vazia, o que retornar?
		
			- O correto é retornar uma lista vazia, quando não tiver os dados.

		Aula 3.6. Cadastrando nova categoria com POST:

			- Utilizar o Post para incluir uma Categoria, enviar com resposta o código 201 e o "Location" que monta a
			uri com a localização do novo recurso (categoria).

			- Pode também ser utilizado para a resposta ser enviada para "body" do Post Http.

			- Implementar a busca de uma categoria via Get, passando o código da categória.

			- O exemplo está utilizando o método findOne() da versão 1.5 do Spring Boot, como estou utilizando a versão
			2.0.4 este método não funciona neste caso tive que usar o método findById() que tem como resposta um objeto
			to tipo Optional<Categoria>.

|------------------------------------------------------------------------------------------>[26/09/2018]

		Aula 3.7. Desafio: Retornar 404 caso não exista a categoria:

			- Na versão Spring Boot 2.0.4 foi feita alteração para desenvolver o desafio:

				@GetMapping("/{codigo}")
				public ResponseEntity<Optional<Categoria>> buscarPeloCodigo(@PathVariable Long codigo) {
					
					Optional<Categoria> categoria = categoriaRepository.findById(codigo);
					
					return categoria.isPresent()  ? ResponseEntity.ok(categoria) : ResponseEntity.notFound().build() ; 
				}

		Aula 3.8. Validando atributos desconhecidos:

			- Utilizar a biblioteca jackson, que faz a converção de objeto java para jason e vice-versa.

			- O jackson permite a deserialização que é transforma de jason para objeto java.

			- No retorno da requisição quanto ao status code http:

				* 2xx -> Sucesso.

				* 4xx -> Erro do cliente.

				* 5xx -> Erro no servidor/serviço.

		Aula 3.9. Tratando erros com ExceptionHandler:

			- Criar uma classe para tratar as excessões.

			- Para a classe capturar a excessão esta precisar ser um controlador Spring que observa toda aplicação (@ControllerAdvice).

|------------------------------------------------------------------------------------------>[07/11/2018]

		Aula 3.10. Validando valores inválidos com Bean Validation:

			- É preciso validar valores enviados para API-RestFull.

			- Tratar a mensagem de erro, para ser mais amigável.

			- Quando colocamos a dependência do spring-boot-jpa já é adicionado o Hibernate Validation.

			- Para personalizar as mensagens do Bean Validation, criar um arquivo "ValidationMessages.properties". Tratar a mensagem
			de validação na classe "AlgamoneyExceptionHandler".

			- Para acessar a mensagem referente a notação, você acessa a classe e no atributo message tem o valor de referência
			que deve ser invocada pelo sistema.

		Aula 3.11. Desafio: Criando o cadastro de pessoa:
		
			- A classe Pessoa tem uma classe associada a ela "Embedded - Embarcada" Endereco, não é uma nova tabela mais uma classe que 
			ajuda organizar a classe Pessoa.

|------------------------------------------------------------------------------------------>[12/11/2018]

		Aula 3.11. Desafio: Criando o cadastro de pessoa (continuação) :

			- Entidade Pessoa : 

				* nome: String
				* ativo: boolean

				*<<embedded>> Endereço:(não é uma tabela no banco de dados, uma classe que ajuda a organizar a classe Pessoa).
				
					* logradouro: String
					* numero: String
					* complemento: String
					* bairro: String
					* cep: String
					* cidade: String
					* estado: String

			- A classe (embedded) Endereço não tem identificador.
			
			- No banco de dados vai ser apenas uma tabela "pessoa", com todos os campos das classes Pessoa e Endereço.

			- No Postman a requisição vai ser construida:

				* [post] localhost:8080/pessoas (raw) (json/application/json)
				* {
					"nome":"xxxxxxxxxxx",
					"endereco":{
						"logradouro":"xxxxxxx",
						"numero":"xxxxxxx",
						"bairro":"xxxxxxx",
						"cep":"xxxxxxx",
						"cidade":"xxxxxxx",
						"estado":"xxxxxxx"
					},
					"ativo":"xxx"
				}

			- Para criar arquivo de migração do flayway:
				
				* Opção criar arquivo na pasta /algamoney-api/src/main/resources/db/migration/V02__criar_e_registrar_pessoas.sql.

				* Quando executar o projeto pelo Spring, o arquivo do de migração do flayway é executado no banco de dados.

		Aula 3.12. Usando eventos para adicionar header Location:
		
			- Toda vez que eu quiser utilizar header location eu vou dispara um evento.

			- Criar uma classe responsável em lançar o evento e outra para escutá-lo. 		 	

	
	Modulo 4 - Atualização e remoção de recursos na API:

		Aula 4.1. Removendo pessoa com DELETE:

			- O retorno do Delete pode ser vazio, então posso usar o HttpStatus 204 (operação foi um sucesso e não tenho 
			nada para retornar).

|------------------------------------------------------------------------------------------>[14/11/2018]

		Aula 4.2 - Sobre atualização de recursos REST:

			- Para atualização de recursos REST usamos o verbo Http "PUT".

			- Podemos utilizar urls(caminhos) diferentes para cada tipo de atualização, se for necessária caso seja parcial,

			- Outra abordagem é utilizar o Patch (Json merge patch), não vai ser utilizada no nosso exemplo.


|------------------------------------------------------------------------------------------>[15/11/2018]
		
		Aula 4.3 - Atualizando pessoa com PUT (atualização completa):

			- Na video aula é apresentado a solução "findOne(codigo)", mas a versão mais nova do Spring deve ser utilizada
			"Pessoa pessoaSalva = pessoaRepository.findById(codigo).get();".

			- Atualização vinda de dúvidas no curso:

				* o método get() do pessoaRepository.findById retorna uma exception do tipo NoSuchElementException caso 
				não encontre nenhum valor para o código informado. Nesse caso, para realizar o tratamento de erros, eu 
				adicionei a referida classe (NoSuchElementException) no método handleEmptyResultDataAccessException da classe 
				AlgamoneyExceptionHandler e mudei o primeiro parâmetro para uma exception mais genérica.

				* @ExceptionHandler({ EmptyResultDataAccessException.class, NoSuchElementException.class })
				public ResponseEntity<Object> handleEmptyResultDataAccessException(RuntimeException ex,
				WebRequest request) {

			- É uma boa prática criar uma classe de serviço para ser a responsável pelas regras de negócio, tirando está
			responsabilidade das classes de controle (resource).

		Aula 4.4. Implementando atualização parcial com PUT:

			- Na url eu tenho que descrever qual a propriedade vai ser atualizada.

|------------------------------------------------------------------------------------------>[16/11/2018]
		
	Módulo 5 - Relacionamentos entre recursos REST:

		Aula 5.1. Criando a migração e entidade de lançamento:

			- A entidade Lançamento tem um relacionamento com Categoria, Pessoa e Tipo de Lançamento(vai ser um Enum).

			- Muitos Lançamentos podem ter uma Categoria, então temos um relacionamento "@ManyToOne".

			- Muitos Lançamentos podem ter uma Pessoa, então temos um relacionamento "@ManyToOne".

			- Utilizar FlayWay para incluir a tabela lançamento no banco de dados.

		Aula 5.2. Desafio: Lista e busca de lançamentos:

			- É preciso adicionar no pom.xml a dependência do Hibernate e do Jackson (faz a conversão do Java para Json e 
			vice versa) para o Java8 tratar o tipo "LocalDate".

			- E para visualizar a data no padrão internacional yyyy-MM-dd no PostMan é preciso alterar application.properties.

		Aula 5.3. Desafio: Cadastrando o primeiro lançamento:

			- Seguir o que já implementado em Pessoa.

		Aula 5.4. Validando inconsistências:

			- É necessário tratar quando não for informado corretamente o código do cliente e a categória, para não exibir um
			erro 500 internal server.

			- Para tratar a exceção, vamos capturar esta na classe AlgamoneyExceptionHandler.

			- Adicionar no pom.xml a biblioteca "commons-lang3" que vai permitir pegar a causa da exceção. 

|------------------------------------------------------------------------------------------>[24/11/2018]

		Aula 5.5. Validando lançamento com Bean Validation:

			- Inserir as mensagens de validação para lançamento, no arquivo "messages.properties".

			- Inserir as anotações do Bean Validation para a classe "Lancamento".

		Aula 5.6. Regra para não salvar pessoa inativa:

			- Introduzir uma regra de negócio em que uma pessoa inativa não pode ter lançamento.

			- Como temos criar uma regra de negócio a boa prática recomenda que se crie uma classe de serviço para lançamento.

			- Como estou usando uma versão mais nova do SpringBoot (2.0), não posso usar o método "findOne()" mas "findById()".
			Entretanto com esse método eu tenho referência a um tipo Optional<Pessoa>, que para ter acesso ao método "isInativo()"
			da classe Pessoa tenho que chamar um método "pessoa.get().isInativo()".

			- O tratamento da exceção da pessoa inativa pode ser feita no própio controlador.

		Aula 5.7. Implementando pesquisa de lançamento com Metamodel:

			- Fazer a pesquisa de lançamento utilizando o Metamodel do Spring Data JPA.

			- Criar uma classe que representa os campos de filtro para lançamento, que eu quero pesquisar.

			- Utilizar a anotação "@DateTimeFormat(pattern="yyyy-MM-dd")" para formatar os campos datas do filtro.

			- Utilizar a Criteria do JPA, já que a Criteria do Hibernate descontinuou.

			- Para criar os meta modelos:

				* Seleciona o projeto >Propriedades> Java compiler> Annotation Processing.

				* Seleciona opção "Enable project specif setting".

				* Informa onde vai gerar as classes "src/main/java"

				* Seleciona a opção "Factory Path".

				* Seleciona a opção "Enable project specific settings".

				* Adiciona uma Jar Externo "hibernate-jpamodelgen", vai criar meta modelos das classes model.


|------------------------------------------------------------------------------------------>[25/11/2018]

	Aula 5.8. Desafio: Removendo lançamentos

		- Implementar a funcionalidade de remover lançamento.

		- Seguir o mesmo procedimento feito em "PessoaResource".

	Aula 5.9. Implementando a paginação de lançamentos:

		- Adicionar parâmetros para a paginação de lançamento.

		- O Spring já disponibiliza parâmetros de paginação, via a classe "Pageable" .

		- É preciso adicionar restrições de paginação na query.

		- Criar uma criteria para calcuar o total de resgistros filtrados.


Módulo 6 - Segurança da API:

	Aula 6.1. Implementando autenticação Basic:

		- Implementar autenticação login e senha na API Rest.

		- Informar a dependência do Spring Security.

		- Nesse exemplo vamos inicialmente utilizar Security Basic. E vamos informar usuário e senha em memória.

		- Para informar usuário e senha é preciso passar a informação através do "Headers" da requisição.

		- Alterar o exemplo da aula para a nova versão do Spring boot 2. Incluir objeto "BCryptPasswordEncoder", chamando o método
		para criptografar a senha.


|------------------------------------------------------------------------------------------>[03/12/2018]

	Aula 6.2. Fluxo básico do OAuth:

		- OAuth 2 é um framework de autorização para o Http.

		- Elementos básico no fluxo do OAuth:

			* Usuário que possui login e senha.

			* Sistema cliente (desktop, web, mobille ...).

			* Servidor de Autorização (Authorization Server).

			* Servidor que tem os recursos (Resource Server).

		- Usuário --> App --(solicita um token) -->	Authorization Server --> App -- (com um token solicita recurso)--> Resource Server

		- Token é uma string com um código de autorização para acessar um recurso.

		- OAuth implementa vários fluxos de autorização.


	Aula 6.3. Implementando segurança com OAuth 2 e Password Flow:
	
		- Solução para o Spring boot 2:

		https://www.algaworks.com/forum/
		topicos/62343/prezados-estou-executando-o-curso-com-a-versao-2-0-0-release-do-spring-boot-ate-entao-eu-nao/

|------------------------------------------------------------------------------------------>[05/12/2018]

	Aula 6.3 - (continuação):

		- Depois de seguir as orientações do forum para adaptar o exemplo ao SpringBoot2. Não deu erro na inicialização do sistema.

		- Com a implantação do OAuth 2 as requisições não podem seguir "Authorization" Basic Auth.

		- Com a implantação do OAuth novos end-points foram adicionados.

|------------------------------------------------------------------------------------------>[06/12/2018]		

	Aula 6.4 - JSON Web Tokens - JWT:

		- O JWT um token mais completo.

		- Site de referência https://jwt.io

		- O JWT é dividido em Header, Payload (dados) e Verify Signature(assinatura de validação do token).

	
	Aula 6.5 - configurando JWT no projeto:
	
		- Adicionar dependência no pom.xml .

		- Utilizar o site https://jwt.io para fazer o debug do token gerado.

	
	Aula 6.6 - Renovando o access token com o refresh token:

		- Você determina quanto tempo o token tem validade.

		- O refresh token permite atualizar um outro access token sem a necessidade de pedir usuário e senha novamente.

		- Um tempo curto para o access token é recomendado por questões de segurança.

		- O refresho token deve ser armazenado em um cookie seguro.

		- Apresentava erro (UserDetailsService) seguir dica do forum:

			*https://www.algaworks.com/forum/
			topicos/62508/para-funcionar-no-spring-boot-2-continuando-minha-descricao-que-postei-nos-comentarios-da-aula-6-3/

|------------------------------------------------------------------------------------------>[07/12/2018]

	Aula 6.7. Movendo o refresh token para o cookie:

		- As boas práticas de segurança recomendam que aplicação não tenha acesso direto ao refresh token.

		- Retirar o refresh token do corpo(body) da resposta e colocar em um cookie seguro (https).

		- Antes do http enviar a resposta intercepto o post com o body da response, capturando o refresh token.

		- O cookie criado deve somente ser utilizado em Http e segurança com Https(para produção).

		- No Postman deve ser desmarcada do body a opção refresh token, com isso ele não envia este mas envia o refresh token
		pelo cookie.

		- Aplicação deve capturar do cookie e colocar na requisição.

	Aula 6.8. Movendo o refresh token do cookie para a requisição:
	
		- Criar uma classe que vai ser um filtro que captura a requisição com alta prioridade.

		- Criar uma nova requisição a partir da requisição capturada e inserir o novo refresh token via cookie.	

	Aula 6.9. O que é CORS?:
	
		- Os browses tem uma proteção de segurança onde o javascript somente pode fazer requisição para o mesmo
		servidor que originou.

		- As exceções so podem ser feitas pelo CORS (http access control), requisições http de origens diferentes.

		- Com anotação do spring "@CrossOrigin" já pertime que objeto seja acessado de diversas origens.

		- O CORS não está totalmente integrado com OAuth 2.

	Aula 6.10. Criando filtro para CORS:
	
		- O filtro que captura a requisição adiciona header http na resposta.

		- Baixei dois prgramas html, que com JavaScript evocam o endpoint de categorias e o token access. Como tenho python
		instalado para chamar o servidor http:

			* $>python -m SimpleHTTPServer 8000

|------------------------------------------------------------------------------------------>[10/12/2018]

	Aula 6.11. Movendo o usuário para o banco de dados:

		- Criando tabelas no banco de dados de usuario, permissao e usuario_permissao. Utilizando a migração do flyway.

		- A senha foi encodada.

		- Criou uma classe util que gera uma senha utilizando "BCryptPasswordEncoder".

		- Estava dando erro no postman, referente a senha de acesso do cliente. Consultando o Apêncie Spring Boot 2 aula "Modificações para
		o Spring Security", a senha do cliente "angular" tem que esta encondada, então usando "BCryptPasswordEncoder" coloquei a senha
		e os testes no postman funcionaram.


	Aula 6.12. Adicionando permissões de acesso:

		- Definir escopo para aplicação, nos métodos.

		- Utilizar permissão de acesso nos métodos.

	
	Aula 6.13. Desafio: Finalizando permissões de acesso:

		- Implementado as ROLE de Lançamento e Pessoa.


	Aula 6.14. Implementando o logout:

		- Para implementar o logout vamos invalidar o token, já que o Oauth 2 não tem nenhum método específico para o logout.

		- Removendo o refresh token do cookie.
		
|------------------------------------------------------------------------------------------>[12/12/2018]

Módulo 7 - Deploy da API em produção :

	Aula 7.1. Implementando projeção de lançamento:

		- Quando fazemos uma consulta no Rest são retornadas diversas informações, podemos fazer com que o retorno seja
		de apenas algumas informações a isso chamamos de projeção.



|------------------------------------------------------------------------------------------>[13/12/2018]		

	Aula 7.2. Profiles do Spring:

		- Configurar propriedades para o sistema executar em diversos ambientes: Desenvolvimento, Testes, Produção...

		- Quando você marca uma linha ou bloco com o comentário "// TODO:"(para fazer), a perspectiva do STS ">Show View >Task List"
		exibe os locais onde tem essas marcações.

		- Criar uma classe que vai agrupar as propriedades configuráveis perfis (profiles).

		- Ele perdeu os meta-modelos tive que retorna a Aula 5.7 e refazer os comandos.


	Aula 7.3. Criando a conta no Heroku:

		- Reativa conta no Herouku.

		- Instalar o Heroku CLI $>sudo snap install --classic heroku.

|------------------------------------------------------------------------------------------>[21/12/2018]

	Aula 7.4. Deploy da API na nuvem:

		- Depois de instalado Herouku CLI, fazer o login "$>heroku login".

		- Para executar o herouku CLI "$/snap/bin> ./heroku login" abre browse para informar login e senha.

		- Para criar no heroku uma pasta com aplicação /snap/bin/./heroku create algamoney-api-lincolnjohn (tem que ser um nome
		exclusivo).

		- Criar suporte ao MySql no heroku /snap/bin/./heroku addons:create jawsdb

		- Consulta a URL do MySql /snap/bin/./heroku config:get JAWSDB_URL

		- Parou (06)

|------------------------------------------------------------------------------------------>[07/01/2019]

	Aula 7.4. Deploy da API na nuvem (continuação) :

		- Foi preciso instalar snap para depois instalar o heroku Cli:

			* sudo apt install snapd

			* sudo snap install --classic heroku

		- A nova versão heroku cli o comando para pegar o valor da variável JAWSDB_URL:
		
			* /snap/bin/./heroku config:get JAWSDB_URL --app algamoney-api-lincolnjohn

		- Criar um arquivo na raiz chamado "ProcFile", com informações da aplicação que vai ser usada pelo heroku.

		- Foi necessário iniciar o git dentro da pasta "$>algamoney-api", para enviar o projeto ao heroku.

			(parei 7:51)

|------------------------------------------------------------------------------------------>[08/01/2019]

	Aula 7.4. Deploy da API na nuvem (continuação) :

		- Para enviar o projeto ao heroku e fazer o deploy "$>git push heroku master"

		- Foi retirada a dependência do pom :

			* <processor>org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor</processor>

			* <artifactId>hibernate-jpamodelgen</artifactId>
			
		- Foi atualizada a versão do Flyway no pom.xml "<version>5.2.4</version>"

		- Para verificar o log do deply "/snap/bin/./heroku logs --tail"

		- Dominio do heroku "https://algamoney-api-lincolnjohn.herokuapp.com/"

	Aula 7.5. Nome do usuário no token JWT : 
	
		- Incluir o nome do usuário no token JWT.

		- Você pode customizar o token adicionando novas informações.

	Aula 7.6. Alternando OAuth 2 e Basic Security com profiles:

		- Utilizado para facilitar o desenvolvimento do front-end Angular.
		
	Aula 7.7. Desafio: Pesquisa de pessoa(finalizado) :
	
		- Baseado no que foi feito para Lancamentos, criar pesquisa de pessoa por nome.

	Aula 7.8. Ajustando o CEP:
	
		- Corrigindo dados do CEP, na tabela Pessoa. Apagar o banco executar novamente a migração.

	Aula 7.9. Desafio: Atualização de lançamento:
	
		- 
	
	


	


	



















			
	














