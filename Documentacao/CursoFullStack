Curso Full Stack e Spring - Algaworks --------------------------------------------------[24/08/2018]

	Modulo 1 - Introdução ao REST:

		Aula 1.1 - Introdução ao curso:

			- Angular, REST e SpringBoot.

			- JavaScript, TypeScript, Html e Css.
			- O projeto exemplo começa com o desenvolvimento Back-End, serviço RESTFull.

			- A parte de apresentação sera Front-End, Angular.

		Aula 1.2 - Suporte:

		Aula 1.3 -  O que é SOFEA:

			- SOFEA (Service-Oriented Front-End Architecture).

			- Remover toda lógica de apresentação do servidor e levar para o cliente.

			- No inicio da conexão faz o download do Html e Css para o cliente, e depois so tráfega dados, como
			padrão JSON.

			- Desenvolvimento Assíncrono do front-end e back-end.

			- Fica mais facil escalabilidade e interoperabilidade (vários clientes).

			- Melhora a experiência do usuário.

		Aula 1.4 - O que é REST:
		
			- Uma forma de integrar sistemas.

			- Front-end -> REST -> Back-end.

			- REST é uma arquitetura com alguns principios que permitem integrar sistemas.

			- REST-Full é uma implementação da arquitetura REST.	

			- API-REST (Aplicattion Program Interface) expõem serviços para aplicações externas.

		Aula 1.5 - Projeto Exemplo:
		
			- Um sistema de lançamento financeiro com débito e crédito.

		Aula 1.6. Ambiente de desenvolvimento REST:

			- SpringBoot, SpringMvc, SpringSecurity e SpringJPA.

			- STS (IDE baseada no Eclipse).

			- Postman (testar as Api-Rest).

			- Pode testar as requisições independente do Front-End.

			- Banco de Dados MySql.
			
------------------------------------------------------------------------------------------[28/08/2018]

		Aula 1.7. Testando APIs com Postman:

			- Utilizando Postman para testar os end-points do Back-End.

			- Utilizar o site www.mocky.io para simular acesso ao Back-End. Vai gerar uma url que depois você coloca no Postman para
			verificar a resposta.

		Aula 1.8. Introdução ao protocolo HTTP:
		
			- Protocolo Http baseado em uma requisição(Request) e obtem uma resposta(Response).	

			- O Http tem um verbo que pode ser GET,POST,PUT,DELETE....

			- O Http tem uma Url para identificar para onde vou fazer a chamada.

			- No Http posso pasar Headers(informações a mais) e Parâmetros(filtros).

			- O Http tem respostas com código(200, 404,500...) identificando o que aconteceu com a requisição recebida.

			- A resposta tem Headers(Content-type)tipo de conteúdo da resposta, tem o corpo da resposta(body) os dados.

	Modulo 2 - Fundamentos do REST:

		Aula 2.1. O que é um recurso?

			- Um recurso tem que ter uma maneira de ser identificado (id por exemplo), uma Uri(uma url completa, com parte que serve 
			para identificar um recurso específico).

		Aula 2.2. Representações de um recurso:
		
			- A mesma Url me traz o mesmo recursos com representações diferentes, que pode ser uma Imagem, Json ou Xml.

			- O recurso pode ter várias representações.	

------------------------------------------------------------------------------------------[29/08/2018]

		Aula 2.3. Modelo de maturidade Richardson - Nível 0:

			- Martin Fowler descreveu o modelo de Richardson para o REST, indo do nível 0 ao 3.

			- No nível 0 não é REST:

				* Http somente como transporte.

				* A solicitação é feita com um único serviço e o código de resposta é a mesma independente de sucesso ou não.

				* Se aproxima de chamar um método remoto.

		Aula 2.4. Modelo de maturidade Richardson - Nível 1:
			
			- O nível 1 ainda não é REST:

				* Já é utilizado o conceito de recurso, passando um identificador.		

				* O código de resposta é unico independete do sucesso ou não.

		Aula 2.5. Modelo de maturidade Richardson - Nível 2:
		
			- O nível 2 já pode ser considerado REST:

				* Já é utilizado os verbos Http (post,get,put....).

				* Posso passar na requisição parâmetros e filtros (query string).

				* A resposta da requisição já modifica o código de retorno.

		Aula 2.6. Modelo de maturidade Richardson - Nível 3	:

			- O nível 3 é um REST completo:

				* Utiliza os verbos Http (post,get,put....).

				* A resposta da requisição já modifica o código de retorno. 

				* Posso passar na requisição parâmetros e filtros (query string).

				* A resposta traz mais informações como a URI para acessar o recurso.

		Aula 2.7. HATEOAS:

			- Hypertexto As Engine Of Application State - HATEOAS.

			- A resposta traz informações adicionais sobre utilizar a URI, para novas ações. Essas informações
			podem ser influenciadas de acordo com regras de négocios.

			- A resposta HATEOS pode ser utilizado para o Front-End ter um determinado comportamento.

------------------------------------------------------------------------------------------[10/09/2018]		
		
		Aula 2.8. Segurança de APIs REST:

			- API privada ou pública.

			- HTTPS o http está criptografado.

			- Autenticação (quem é você ) e Autorização (áreas que você pode acessar).

			- Tipos de segurança para o Https Basic, Digest, Certificados e Tokens.

			- OAuth foi criado para fazer autorização. Você é autorizado por outro sites que não o seu.

		Aula 2.9. Idempotência:
		
			- Um método é considerado idempontente se o resultado produzido por ele é o mesmo independente
			do número de vezes que for executado.

	Modulo 3 - Primeiras consultas e cadastros na API:

		Aula 3.1. Criando o projeto da API:

			- Utilizando o STS para iniciar o projeto, através do Spring Boot. Selecionar as dependência da Web, Jpa e Devtools.

			- Vou utilizar a versão 2.0.4 do spring boot.

		Aula 3.2. Conectando ao MySQL:
		
			- Configuração do Banco de Dados MySQL no arquivo /algamoney-api/src/main/resources/application.properties.

			- Utilizar WorkBench para gerenciar o MySql.

		Aula 3.3. Migração de dados com Flyway:
		
			- Não utilizar a geração de tabelas no banco com Hibernate. Em ambiente de produção deve ser utilizado uma 
			ferramenta de migração.

			- Vamos utilizar a ferramenta de migração Flyway.

			- Vamos criar scripts para o banco de dados de forma incremental, com isso garantindo rastreabilidade nas 
			versões do banco.
				
------------------------------------------------------------------------------------------[11/09/2018]		

		Aula 3.4. Consultando primeiro recurso com GET:

			- A tabela Categoria está populada, então vamos implementar o GET para retornar uma lista de categórias.

			- Criar uma interface de Categoria que extende a JpaRepository (framework spring), que tem vários métodos 
			de manipulação de banco de dados.

			- Criar a classe que vai expor o recursos de Categoria. Um controlador rest.

		Aula 3.5. Coleção vazia, o que retornar?
		
			- O correto é retornar uma lista vazia, quando não tiver os dados.

		Aula 3.6. Cadastrando nova categoria com POST:

			- Utilizar o Post para incluir uma Categoria, enviar com resposta o código 201 e o "Location" que monta a
			uri com a localização do novo recurso (categoria).

			- Pode também ser utilizado para a resposta ser enviada para "body" do Post Http.

			- Implementar a busca de uma categoria via Get, passando o código da categória.

			- O exemplo está utilizando o método findOne() da versão 1.5 do Spring Boot, como estou utilizando a versão
			2.0.4 este método não funciona neste caso tive que usar o método findById() que tem como resposta um objeto
			to tipo Optional<Categoria>.

|------------------------------------------------------------------------------------------>[26/09/2018]

		Aula 3.7. Desafio: Retornar 404 caso não exista a categoria:

			- Na versão Spring Boot 2.0.4 foi feita alteração para desenvolver o desafio:

				@GetMapping("/{codigo}")
				public ResponseEntity<Optional<Categoria>> buscarPeloCodigo(@PathVariable Long codigo) {
					
					Optional<Categoria> categoria = categoriaRepository.findById(codigo);
					
					return categoria.isPresent()  ? ResponseEntity.ok(categoria) : ResponseEntity.notFound().build() ; 
				}

		Aula 3.8. Validando atributos desconhecidos:

			- Utilizar a biblioteca jackson, que faz a converção de objeto java para jason e vice-versa.

			- O jackson permite a deserialização que é transforma de jason para objeto java.

			- No retorno da requisição quanto ao status code http:

				* 2xx -> Sucesso.

				* 4xx -> Erro do cliente.

				* 5xx -> Erro no servidor/serviço.

		Aula 3.9. Tratando erros com ExceptionHandler:

			- Criar uma classe para tratar as excessões.

			- Para a classe capturar a excessão esta precisar ser um controlador Spring que observa toda aplicação (@ControllerAdvice).

|------------------------------------------------------------------------------------------>[07/11/2018]

		Aula 3.10. Validando valores inválidos com Bean Validation:

			- É preciso validar valores enviados para API-RestFull.

			- Tratar a mensagem de erro, para ser mais amigável.

			- Quando colocamos a dependência do spring-boot-jpa já é adicionado o Hibernate Validation.

			- Para personalizar as mensagens do Bean Validation, criar um arquivo "ValidationMessages.properties". Tratar a mensagem
			de validação na classe "AlgamoneyExceptionHandler".

			- Para acessar a mensagem referente a notação, você acessa a classe e no atributo message tem o valor de referência
			que deve ser invocada pelo sistema.

		Aula 3.11. Desafio: Criando o cadastro de pessoa:
		
			- A classe Pessoa tem uma classe associada a ela "Embedded - Embarcada" Endereco, não é uma nova tabela mais uma classe que 
			ajuda organizar a classe Pessoa.

|------------------------------------------------------------------------------------------>[12/11/2018]

		Aula 3.11. Desafio: Criando o cadastro de pessoa (continuação) :

			- Entidade Pessoa : 

				* nome: String
				* ativo: boolean

				*<<embedded>> Endereço:(não é uma tabela no banco de dados, uma classe que ajuda a organizar a classe Pessoa).
				
					* logradouro: String
					* numero: String
					* complemento: String
					* bairro: String
					* cep: String
					* cidade: String
					* estado: String

			- A classe (embedded) Endereço não tem identificador.
			
			- No banco de dados vai ser apenas uma tabela "pessoa", com todos os campos das classes Pessoa e Endereço.

			- No Postman a requisição vai ser construida:

				* [post] localhost:8080/pessoas (raw) (json/application/json)
				* {
					"nome":"xxxxxxxxxxx",
					"endereco":{
						"logradouro":"xxxxxxx",
						"numero":"xxxxxxx",
						"bairro":"xxxxxxx",
						"cep":"xxxxxxx",
						"cidade":"xxxxxxx",
						"estado":"xxxxxxx"
					},
					"ativo":"xxx"
				}

			- Para criar arquivo de migração do flayway:
				
				* Opção criar arquivo na pasta /algamoney-api/src/main/resources/db/migration/V02__criar_e_registrar_pessoas.sql.

				* Quando executar o projeto pelo Spring, o arquivo do de migração do flayway é executado no banco de dados.

		Aula 3.12. Usando eventos para adicionar header Location:
		
			- Toda vez que eu quiser utilizar header location eu vou dispara um evento.

			- Criar uma classe responsável em lançar o evento e outra para escutá-lo. 		 	

	
	Modulo 4 - Atualização e remoção de recursos na API:

		Aula 4.1. Removendo pessoa com DELETE:

			- O retorno do Delete pode ser vazio, então posso usar o HttpStatus 204 (operação foi um sucesso e não tenho 
			nada para retornar).

|------------------------------------------------------------------------------------------>[14/11/2018]

		Aula 4.2 - Sobre atualização de recursos REST:

			- Para atualização de recursos REST usamos o verbo Http "PUT".

			- Podemos utilizar urls(caminhos) diferentes para cada tipo de atualização, se for necessária caso seja parcial,

			- Outra abordagem é utilizar o Patch (Json merge patch), não vai ser utilizada no nosso exemplo.


|------------------------------------------------------------------------------------------>[15/11/2018]
		
		Aula 4.3 - Atualizando pessoa com PUT (atualização completa):

			- Na video aula é apresentado a solução "findOne(codigo)", mas a versão mais nova do Spring deve ser utilizada
			"Pessoa pessoaSalva = pessoaRepository.findById(codigo).get();".

			- Atualização vinda de dúvidas no curso:

				* o método get() do pessoaRepository.findById retorna uma exception do tipo NoSuchElementException caso 
				não encontre nenhum valor para o código informado. Nesse caso, para realizar o tratamento de erros, eu 
				adicionei a referida classe (NoSuchElementException) no método handleEmptyResultDataAccessException da classe 
				AlgamoneyExceptionHandler e mudei o primeiro parâmetro para uma exception mais genérica.

				* @ExceptionHandler({ EmptyResultDataAccessException.class, NoSuchElementException.class })
				public ResponseEntity<Object> handleEmptyResultDataAccessException(RuntimeException ex,
				WebRequest request) {

			- É uma boa prática criar uma classe de serviço para ser a responsável pelas regras de negócio, tirando está
			responsabilidade das classes de controle (resource).

		Aula 4.4. Implementando atualização parcial com PUT:

			- Na url eu tenho que descrever qual a propriedade vai ser atualizada.

|------------------------------------------------------------------------------------------>[16/11/2018]
		
	Módulo 5 - Relacionamentos entre recursos REST:

		Aula 5.1. Criando a migração e entidade de lançamento:

			- A entidade Lançamento tem um relacionamento com Categoria, Pessoa e Tipo de Lançamento(vai ser um Enum).

			- Muitos Lançamentos podem ter uma Categoria, então temos um relacionamento "@ManyToOne".

			- Muitos Lançamentos podem ter uma Pessoa, então temos um relacionamento "@ManyToOne".

			- Utilizar FlayWay para incluir a tabela lançamento no banco de dados.

		Aula 5.2. Desafio: Lista e busca de lançamentos:

			- É preciso adicionar no pom.xml a dependência do Hibernate e do Jackson (faz a conversão do Java para Json e 
			vice versa) para o Java8 tratar o tipo "LocalDate".

			- E para visualizar a data no padrão internacional yyyy-MM-dd no PostMan é preciso alterar application.properties.

		Aula 5.3. Desafio: Cadastrando o primeiro lançamento:

			- Seguir o que já implementado em Pessoa.

		Aula 5.4. Validando inconsistências:

			- É necessário tratar quando não for informado corretamente o código do cliente e a categória, para não exibir um
			erro 500 internal server.

			- Para tratar a exceção, vamos capturar esta na classe AlgamoneyExceptionHandler.

			- Adicionar no pom.xml a biblioteca "commons-lang3" que vai permitir pegar a causa da exceção. 

|------------------------------------------------------------------------------------------>[24/11/2018]

		Aula 5.5. Validando lançamento com Bean Validation:

			- Inserir as mensagens de validação para lançamento, no arquivo "messages.properties".

			- Inserir as anotações do Bean Validation para a classe "Lancamento".

		Aula 5.6. Regra para não salvar pessoa inativa:

			- Introduzir uma regra de negócio em que uma pessoa inativa não pode ter lançamento.

			- Como temos criar uma regra de negócio a boa prática recomenda que se crie uma classe de serviço para lançamento.

			- Como estou usando uma versão mais nova do SpringBoot (2.0), não posso usar o método "findOne()" mas "findById()".
			Entretanto com esse método eu tenho referência a um tipo Optional<Pessoa>, que para ter acesso ao método "isInativo()"
			da classe Pessoa tenho que chamar um método "pessoa.get().isInativo()".

			- O tratamento da exceção da pessoa inativa pode ser feita no própio controlador.

		Aula 5.7. Implementando pesquisa de lançamento com Metamodel:

			- Fazer a pesquisa de lançamento utilizando o Metamodel do Spring Data JPA.

			- Criar uma classe que representa os campos de filtro para lançamento, que eu quero pesquisar.

			- Utilizar a anotação "@DateTimeFormat(pattern="yyyy-MM-dd")" para formatar os campos datas do filtro.

			- Utilizar a Criteria do JPA, já que a Criteria do Hibernate descontinuou.

			- Para criar os meta modelos:

				* Seleciona o projeto >Propriedades> Java compiler> Annotation Processing.

				* Seleciona opção "Enable project specif setting".

				* Informa onde vai gerar as classes "src/main/java"

				* Seleciona a opção "Factory Path".

				* Seleciona a opção "Enable project specific settings".

				* Adiciona uma Jar Externo "hibernate-jpamodelgen", vai criar meta modelos das classes model.


|------------------------------------------------------------------------------------------>[25/11/2018]

	Aula 5.8. Desafio: Removendo lançamentos

		- Implementar a funcionalidade de remover lançamento.

		- Seguir o mesmo procedimento feito em "PessoaResource".

	Aula 5.9. Implementando a paginação de lançamentos:

		- Adicionar parâmetros para a paginação de lançamento.

		- O Spring já disponibiliza parâmetros de paginação, via a classe "Pageable" .

		- É preciso adicionar restrições de paginação na query.

		- Criar uma criteria para calcuar o total de resgistros filtrados.


Módulo 6 - Segurança da API:

	Aula 6.1. Implementando autenticação Basic:

		- Implementar autenticação login e senha na API Rest.

		- Informar a dependência do Spring Security.

		- Nesse exemplo vamos inicialmente utilizar Security Basic. E vamos informar usuário e senha em memória.

		- Para informar usuário e senha é preciso passar a informação através do "Headers" da requisição.

		- Alterar o exemplo da aula para a nova versão do Spring boot 2. Incluir objeto "BCryptPasswordEncoder", chamando o método
		para criptografar a senha.


|------------------------------------------------------------------------------------------>[03/12/2018]

	Aula 6.2. Fluxo básico do OAuth:

		- OAuth 2 é um framework de autorização para o Http.

		- Elementos básico no fluxo do OAuth:

			* Usuário que possui login e senha.

			* Sistema cliente (desktop, web, mobille ...).

			* Servidor de Autorização (Authorization Server).

			* Servidor que tem os recursos (Resource Server).

		- Usuário --> App --(solicita um token) -->	Authorization Server --> App -- (com um token solicita recurso)--> Resource Server

		- Token é uma string com um código de autorização para acessar um recurso.

		- OAuth implementa vários fluxos de autorização.


	Aula 6.3. Implementando segurança com OAuth 2 e Password Flow:
	
		- Solução para o Spring boot 2:

		https://www.algaworks.com/forum/
		topicos/62343/prezados-estou-executando-o-curso-com-a-versao-2-0-0-release-do-spring-boot-ate-entao-eu-nao/

|------------------------------------------------------------------------------------------>[05/12/2018]

	Aula 6.3 - (continuação):

		- Depois de seguir as orientações do forum para adaptar o exemplo ao SpringBoot2. Não deu erro na inicialização do sistema.

		- Com a implantação do OAuth 2 as requisições não podem seguir "Authorization" Basic Auth.

		- Com a implantação do OAuth novos end-points foram adicionados.

|------------------------------------------------------------------------------------------>[06/12/2018]		

	Aula 6.4 - JSON Web Tokens - JWT:

		- O JWT um token mais completo.

		- Site de referência https://jwt.io

		- O JWT é dividido em Header, Payload (dados) e Verify Signature(assinatura de validação do token).

	
	Aula 6.5 - configurando JWT no projeto:
	
		- Adicionar dependência no pom.xml .

		- Utilizar o site https://jwt.io para fazer o debug do token gerado.

	
	Aula 6.6 - Renovando o access token com o refresh token:

		- Você determina quanto tempo o token tem validade.

		- O refresh token permite atualizar um outro access token sem a necessidade de pedir usuário e senha novamente.

		- Um tempo curto para o access token é recomendado por questões de segurança.

		- O refresho token deve ser armazenado em um cookie seguro.

		- Apresentava erro (UserDetailsService) seguir dica do forum:

			*https://www.algaworks.com/forum/
			topicos/62508/para-funcionar-no-spring-boot-2-continuando-minha-descricao-que-postei-nos-comentarios-da-aula-6-3/

|------------------------------------------------------------------------------------------>[07/12/2018]

	Aula 6.7. Movendo o refresh token para o cookie:

		- As boas práticas de segurança recomendam que aplicação não tenha acesso direto ao refresh token.

		- Retirar o refresh token do corpo(body) da resposta e colocar em um cookie seguro (https).

		- Antes do http enviar a resposta intercepto o post com o body da response, capturando o refresh token.

		- O cookie criado deve somente ser utilizado em Http e segurança com Https(para produção).

		- No Postman deve ser desmarcada do body a opção refresh token, com isso ele não envia este mas envia o refresh token
		pelo cookie.

		- Aplicação deve capturar do cookie e colocar na requisição.

	Aula 6.8. Movendo o refresh token do cookie para a requisição:
	
		- Criar uma classe que vai ser um filtro que captura a requisição com alta prioridade.

		- Criar uma nova requisição a partir da requisição capturada e inserir o novo refresh token via cookie.	

	Aula 6.9. O que é CORS?:
	
		- Os browses tem uma proteção de segurança onde o javascript somente pode fazer requisição para o mesmo
		servidor que originou.

		- As exceções so podem ser feitas pelo CORS (http access control), requisições http de origens diferentes.

		- Com anotação do spring "@CrossOrigin" já pertime que objeto seja acessado de diversas origens.

		- O CORS não está totalmente integrado com OAuth 2.

	Aula 6.10. Criando filtro para CORS:
	
		- O filtro que captura a requisição adiciona header http na resposta.

		- Baixei dois prgramas html, que com JavaScript evocam o endpoint de categorias e o token access. Como tenho python
		instalado para chamar o servidor http:

			* $>python -m SimpleHTTPServer 8000

|------------------------------------------------------------------------------------------>[10/12/2018]

	Aula 6.11. Movendo o usuário para o banco de dados:

		- Criando tabelas no banco de dados de usuario, permissao e usuario_permissao. Utilizando a migração do flyway.

		- A senha foi encodada.

		- Criou uma classe util que gera uma senha utilizando "BCryptPasswordEncoder".

		- Estava dando erro no postman, referente a senha de acesso do cliente. Consultando o Apêncie Spring Boot 2 aula "Modificações para
		o Spring Security", a senha do cliente "angular" tem que esta encondada, então usando "BCryptPasswordEncoder" coloquei a senha
		e os testes no postman funcionaram.


	Aula 6.12. Adicionando permissões de acesso:

		- Definir escopo para aplicação, nos métodos.

		- Utilizar permissão de acesso nos métodos.

	
	Aula 6.13. Desafio: Finalizando permissões de acesso:

		- Implementado as ROLE de Lançamento e Pessoa.


	Aula 6.14. Implementando o logout:

		- Para implementar o logout vamos invalidar o token, já que o Oauth 2 não tem nenhum método específico para o logout.

		- Removendo o refresh token do cookie.
		
|------------------------------------------------------------------------------------------>[12/12/2018]

Módulo 7 - Deploy da API em produção :

	Aula 7.1. Implementando projeção de lançamento:

		- Quando fazemos uma consulta no Rest são retornadas diversas informações, podemos fazer com que o retorno seja
		de apenas algumas informações a isso chamamos de projeção.



|------------------------------------------------------------------------------------------>[13/12/2018]		

	Aula 7.2. Profiles do Spring:

		- Configurar propriedades para o sistema executar em diversos ambientes: Desenvolvimento, Testes, Produção...

		- Quando você marca uma linha ou bloco com o comentário "// TODO:"(para fazer), a perspectiva do STS ">Show View >Task List"
		exibe os locais onde tem essas marcações.

		- Criar uma classe que vai agrupar as propriedades configuráveis perfis (profiles).

		- Ele perdeu os meta-modelos tive que retorna a Aula 5.7 e refazer os comandos.


	Aula 7.3. Criando a conta no Heroku:

		- Reativa conta no Herouku.

		- Instalar o Heroku CLI $>sudo snap install --classic heroku.

|------------------------------------------------------------------------------------------>[21/12/2018]

	Aula 7.4. Deploy da API na nuvem:

		- Depois de instalado Herouku CLI, fazer o login "$>heroku login".

		- Para executar o herouku CLI "$/snap/bin> ./heroku login" abre browse para informar login e senha.

		- Para criar no heroku uma pasta com aplicação /snap/bin/./heroku create algamoney-api-lincolnjohn (tem que ser um nome
		exclusivo).

		- Criar suporte ao MySql no heroku /snap/bin/./heroku addons:create jawsdb

		- Consulta a URL do MySql /snap/bin/./heroku config:get JAWSDB_URL

		- Parou (06)

|------------------------------------------------------------------------------------------>[07/01/2019]

	Aula 7.4. Deploy da API na nuvem (continuação) :

		- Foi preciso instalar snap para depois instalar o heroku Cli:

			* sudo apt install snapd

			* sudo snap install --classic heroku

		- A nova versão heroku cli o comando para pegar o valor da variável JAWSDB_URL:
		
			* /snap/bin/./heroku config:get JAWSDB_URL --app algamoney-api-lincolnjohn

		- Criar um arquivo na raiz chamado "ProcFile", com informações da aplicação que vai ser usada pelo heroku.

		- Foi necessário iniciar o git dentro da pasta "$>algamoney-api", para enviar o projeto ao heroku.

			(parei 7:51)

|------------------------------------------------------------------------------------------>[08/01/2019]

	Aula 7.4. Deploy da API na nuvem (continuação) :

		- Para enviar o projeto ao heroku e fazer o deploy "$>git push heroku master"

		- Foi retirada a dependência do pom :

			* <processor>org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor</processor>

			* <artifactId>hibernate-jpamodelgen</artifactId>
			
		- Foi atualizada a versão do Flyway no pom.xml "<version>5.2.4</version>"

		- Para verificar o log do deply "/snap/bin/./heroku logs --tail"

		- Dominio do heroku "https://algamoney-api-lincolnjohn.herokuapp.com/"

	Aula 7.5. Nome do usuário no token JWT : 
	
		- Incluir o nome do usuário no token JWT.

		- Você pode customizar o token adicionando novas informações.

	Aula 7.6. Alternando OAuth 2 e Basic Security com profiles:

		- Utilizado para facilitar o desenvolvimento do front-end Angular.
		
	Aula 7.7. Desafio: Pesquisa de pessoa(finalizado) :
	
		- Baseado no que foi feito para Lancamentos, criar pesquisa de pessoa por nome.

	Aula 7.8. Ajustando o CEP:
	
		- Corrigindo dados do CEP, na tabela Pessoa. Apagar o banco executar novamente a migração.

	Aula 7.9. Desafio: Atualização de lançamento (finalizado):
	
	
Módulo 8 - Introdução ao Angular:

	Aula 8.1. O que é Angular?

		- Angular framework javascript para construção de front-end na web.

		- Angular utiliza a linguagem TypeScript que vai ser compilada para javascript.

		- Angular permite desenvolver uma SPA (single page application).

		- Vamos utilizar PrimeNG uma biblioteca de componentes para Angular.

	Aula 8.2. AngularJS vs Angular 2/4/X: a confusão das versões:

		- AngularJS 1.x não vai mais evoluir.

		- Angular 2 é outra tecnologia diferente da AngularJS.

	Aula 8.3. Instalando o Visual Studio Code:

		- 
|------------------------------------------------------------------------------------------>[09/01/2019]

	Aula 8.4. Introdução ao HTML:

		- Html (hyper text markup language) linguagem de marcação de hipertexto.

		- Tags são palavras chaves cercadas pelos sinais de maior e menor "<h1>".

		- Tag de abertura "<p>" e de fechamento "</p>".

		- Tags auto-fechadas "<br/>" ou "<br>".

		- Atributos palavras chaves dentro das tags, que dão contexto a tag "<a href='www.google.com'>Clique aqui</a>".

	
	Aula 8.5. Introdução ao CSS:

		- Css (cascading style sheet) folha de estilo em cascata.

		- O estilo segue a ordem do mais específico para o menos específico.

		- Atributos e seletores fonte https://developer.mozilla.org/pt-BR/ .

	
	Aula 8.6. Instalando o Node.js e NPM:

		- NodeJs plataforma para construir aplicações em javascript, que rodam um servidor em tempo de desenvolvimento.

		- Para instalação do NodeJs(Debian 9):
			
			* sudo apt install curl
			
			* sudo curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
			
			* sudo apt-get install -y nodejs (já instala npm).

	
	Aula 8.7. Instalando e criando um projeto com Angular CLI:
	
		- Angular CLI ferramenta que automatiza a criação de projetos Angular.

		- O comando $>npm cache clean (limpa o cache local do PC no caso de ter uma isntalação antiga).

		- Para instalar $>sudo npm install -g @angular/cli .

		- Para ver a versão $>ng version .

		- Para criar um projeto $>ng new <meu projeto>.

		- Para iniciar o servidor dentro do projeto $>ng serve

		- O servidor por padrão sobe na pota localhost:4200, mas podemos mudar de porta $>ng serve --port 4900

	
	Aula 8.8. Abrindo o projeto no VS Code:

		- O Angular CLI, cria as dependências do projeto em nível de produção e desenvolvimento.

		- Na pasta "\node_modules" estão baixadas todas as dependências do projeto.

	
	Aula 8.9. Abrindo e executando um exemplo do curso:

		- Quando a pasta "\node_modules" não estiver no projeto deve ser executado o comando "$>npm install", onde é 
		criada a pasta com as dependências do projeto.


Módulo 9 - Fundamentos do Angular, componentes e data binding:

	Aula 9.1. Bootstrapping e AppModule:

		- A framework injeta arquivos javascript, que vão ser utilizados na aplicação criados pelo Angular CLI.

		- O componente raiz do angular na aplicação "<app-root></app-root>".

		- Uma aplicação Angular é formada por módulos.

		- Quando aplicação inicia é chamado o 'app.module.ts'. Onde se identifica qual o módulo inicial da aplicação.

|------------------------------------------------------------------------------------------>[11/01/2019]

	Aula 9.2. O que são componentes:

		- Uma aplicação Angular é uma combinação de componentes.

		- Os componentes podem ser reaproveitados.

		- Quebrar aplicação em vários componentes depende dos objetivos deste.


	Aula 9.3. Criando um componente:

		- Você pode criar o componente de forma manual ou usando o AngularCli.

		- No decorate "@Component" você define o nome da tag que vai identificar o componente através do metadados 
		"selector:"

		- Usando a crase ` `, posso fazer a concatenação de string.

		- Criar um componente utilizando AngularCLI, "$>ng g c cliente --spec=false"

	Aula 9.4. Instalando a biblioteca CSS do Bootstrap:

		- Bootstrap é um framework para aplicações web (html,css e javascript), onde vamos utilizar apenas em alguns exemplos.

		- Para instalar o bootstrap no seu projeto, "$>npm install bootstrap --save" instala a versão mais recente.

	Aula 9.5. Introdução a data binding:

		- Data binding vincula componente ao template e vice-versa.

	Aula 9.6. Usando interpolação:

		- Usamos interpolação de string para adicionar no Html algum resultado calculado por uma expressão de template ou
		a propriedade de um componente.

		- Data binding é um tipo de interpolação.

		- Podemos colocar expressões typescript que podem ser convertidas em string, no html.

	Aula 9.7. Usando event binding:

		- (2:28)

|------------------------------------------------------------------------------------------>[14/01/2019]


	Aula 9.7. Usando event binding(continuação):

		- Preparar o Angular para reagir ações do usuário, através de eventos.

		- Foi necessário reinstalar visual studio code.

		- "` `" chamado de template literal, onde concatena os valores dentro da crase dupla.

		- Utilizar event biding do angular "on-click".

		- Você pode utilizar as formas para capturar evento de click no botão:

			* on-click = "nome do método".

			* (click) = "nome do método".

	Aula 9.8. Usando variável de referência:
	
		- Você pode identificar uma tag com uma variável de referência.


	Aula 9.9. Usando property binding:

		- Utilizando propriedades das tag com referências de uma expressão typescript.

		- O property binding busca do componente para o template.

	Aula 9.10. Usando two-way data binding:

		- Criando vinculo dos dois lados componete para o template, template para o componente two-way.


	Aula 9.11. Introdução às diretivas:

		- Diretivas são instruções usadas no Angular que podem ser:

			* Componentes (adicionamos um componente no template).

			* Diretivas Estruturais (modifica a estrutura do DOM documento, adicionando ou removendo elemento) .

			* Diretivas de Atributos (modifica aparência do elemento).

		- Podemos customizar diretivas.	

|------------------------------------------------------------------------------------------>[16/01/2019]

	Aula 9.12. Exibindo condicionalmente com as diretivas ngIf e hidden:

		- ngIf é uma diretiva estrutural, porque altera a estrutura do DOM.

		- O atributo "hidden" tem um comportamento similar ao "ngIf", entretanto ele não altera a estrutura do DOM apenas
		oculta a informação.

		- O "hidem" tem um desempenho no processamento melhor que o "ngIf". A opção em usar um ou outro depende das características do 
		aplicativo que se está desenvolvendo.


	Aula 9.13. Iterando com a diretiva ngFor:
	
		- Vamos usar um componente do Bootstrap "Card" https://getbootstrap.com/docs/4.0/components/card/.

		- Utilizar um site que fornece fotos aleatórias https://randomuser.me/api/portraits/lego/1.jpg

		- A diretiva "ngFor" faz um iteração um loop.

		- Estava dando problema na hora de salvar arquivo(Vscode) , o encode UTF-8 estva sendo perdido. Uma dica da internet falou
		que a barra inferior mostra o encode estava errado troquei para UTF-8 funcionou.


|------------------------------------------------------------------------------------------>[17/01/2019]

	Aula 9.14. Binding de propriedades customizadas com @Input:

		- O comando "$>ng g c funcionario-card", cria um componente.

		- Para expor uma propriedade para fora do componente usamos "@Input()".

		- Podemos criar componentes que podem ser reutilizados.


	Aula 9.15. Binding de eventos customizados com @Output e EventEmitter:

		- Para expor um evento para fora do componente usamos "@Output()".

		- Na comunicação entre componentes fazemos um binding de eventos, que chama um método, ou bindig de propriedades. 


	Aula 9.16. Adicionando estilos CSS em componentes:

		- Você pode personalizar o estilos CSS para os componentes.


|------------------------------------------------------------------------------------------>[18/01/2019]		


	Aula 9.17. Estilos CSS dinâmicos com ngStyle:

		- Adicionar estilo css de forma dinâmica utilizando diretiva ngStyle.

		- Uma diretiva pode alterar o comportamento ou aparência de um componente ou elemento.


	Aula 9.18. Classes CSS dinâmicas com ngClass:

		- As diretivas podem trabalhar em conjunto com as propriedades do Html.


Módulo 10 - Páginas de pesquisas:


	Aula 10.1. Instalando plugins úteis no Visual Studio Code:

		- Quando criamos o projeto pelo Angular CLI, é instalado uma ferramenta para analisar o nosso código, informando
		problemas de sintaxe, boas práticas e legibilidade (tslint).

		- Executar o comando "$>/projetoteste/node_modules/tslint/bin/"

		
|------------------------------------------------------------------------------------------>[21/01/2019]

	Aula 10.2. Escolhendo uma biblioteca de componentes:

		- Bibliotecas de componentes para Angular:

			* https://material.angular.io/

			* https://www.primefaces.org/primeng/#/

			* http://angular2-materialize.surge.sh/#/Buttons

			* https://ng-bootstrap.github.io/


	Aula 10.3. Criando o projeto do curso e instalando o PrimeNG:

		- Executar o comando "$>ng new algamoney-ui" para iniciar o projeto no AngularCLI.

		- Instalar a biblioteca de componentes do PrimeNG no projeto "$>npm install primeng --save".

		- Instalar uma dependência do primeng para icones "fontawesome.io" "$>npm install fontawesome --save"

		- Acresentar na configuração do projeto as fontes css do primeng e fontawesome, quando empacotar o mesmo:

		 	"styles": [
              "./node_modules/font-awesome/css/font-awesome.min.css",
              "./node_modules/primeng/resources/themes/nova-light/theme.css",
              "./node_modules/primeng/resources/primeng.min.css",
              "src/styles.css"
            ],

		- Desintalar um componente "$>npm uninstall fontawesome --save".


	Aula 10.4. Adicionando o formulário de pesquisa de lançamentos:
	
		- Para permitir que o sistema fique responsivo, temos que trabalhar com Grid CSS.

|------------------------------------------------------------------------------------------>[23/01/2019]		   
	
	Aula 10.5. Adicionando uma tabela de dados:

		- A versão nova PrimeNG não utiliza o componente "p-dataTable" que foi substituido por "p-Table", que foi utilizado
		no exemplo.

		- O estilo que foi aplicado também ficou diferente:

			* @Component({
				  selector: 'app-root',
				  templateUrl: './app.component.html',
				  styleUrls: ['./app.component.css'],
				  styles:[`
				  .col-data-header{
				    width:120px;
				    text-align: center;
				  }

				  .col-data{
				    width: 120px;
				    text-align: center;
				  }

				  .col-valor-header{
				    width:120px;
				    text-align: center;
				  }

				  .col-valor{
				    width: 120px;
				    text-align: right;
				  }
				`]
				})

			* <th [ngClass]="{'col-data':true}" >Vencimento</th>

			* <td [ngClass]="{'col-data':true}"  >{{lancamento.dataVencimento}}</td>


	Aula 10.6. Customizando colunas com ng-template:

		- Como estou utilizando uma versão mais nova PrimeNG, tive que fazer adaptações no código.

		
|------------------------------------------------------------------------------------------>[28/01/2019]

	Aula 10.7. Fazendo paginação de dados:

		- Adicionar recurso de paginação em uma datatable do primeng.

		- Adicionar a biblioteca de icones primeicons.css:

			1. Execute o comando: npm install primeicons --save

			2. Navegue até o seu aquivo angular.json e dentro de styles adicione a referência do primeicons. Desta forma:

			 "styles": [
			 "node_modules/primeicons/primeicons.css",
			 "src/styles.css"
			 ],

	Aula 10.8. Adicionando tooltip:

		- Diretiva que permite acrescentar informações adicionais nos campos de dados.

		- Os componetes do PrimeNG precisam ser importados em "app.module.ts" .


	Aula 10.9. Colocando a tabela de dados responsiva:

		- Permitindo aplicação ser e utilizada em diversos dispositivos com resolução diferente.

	
	Aula 10.10. Criando o componente de pesquisa de lançamentos:
	
		- Para criar um componente pelo AngularCli, "$>ng g c lancamentos-pesquisa" .

|------------------------------------------------------------------------------------------>[29/01/2019]

	Aula 10.11. Criando o componente de barra de navegação:

		- Criar um componente de barra de navegação, no terminal digita o comando "$>ng g c navbar --spec=false" .


	Aula 10.12. Adicionando menu intercambiável:

		- Criando estilo css para componente de menu.

	Aula 10.13. Desafio: criando componente de pesquisa de pessoas:
	
		- Desafio OK
	
|------------------------------------------------------------------------------------------>[31/01/2019]


Módulo 11 Diretivas e pipes 


	Aula 11.1. Criando diretivas customizadas:

		- Usar o projeto de teste usado no inicio do curso.

		- Usar o comando $>ng g d campo-colorido --spec=false (gera uma diretiva chamada campo-colorido).

		- Construir uma diretiva para mudar o estilo de um campo.


	Aula 11.2. Respondendo a eventos do hospedeiro com @HostListener:

		- Acionar a diretiva quando existir algum evento, elemento receber o foco.

		- O aplicativo vai ficar escutando um evento, com o decorator "@HostListener ('evento do DOM')" identificamos
		o evento com a diretiva.

		- Podemos criar diretivas que podem ser reaproveitadas na aplicação toda.


	Aula 11.3. Vinculando propriedades do hospedeiro com @HostBinding:

		- Podemos utilizar de outra maneira a diretiva, não utilizando o "Renderer2".

		- Utilizando o decorator "@HostBinding('propriedade DOM')" vinculando a diretiva ao valor de uma variável.


	Aula 11.4. Usando property binding em diretivas customizadas:

		- Defino uma propriedade da diretiva, que eu informo o valor na construção da minha interface.


	Aula 11.5. Exportando a API da diretiva para o template:

		- Permite você expor a diretiva para ser usada em outras partes da aplicação.


|------------------------------------------------------------------------------------------>[04/02/2019]

	Aula 11.6. Conhecendo e usando pipes:

		- Pipe é uma funcionalidade que pega um valor de entrada e gera um valor de saída, formatado.

		- Um pipe nativo já vem com Angular.

		- Exemplos de pipes nativos:

			* {{variável | uppercase}} (transforma para maíuscula)

			* {{variável | date}} (transforma para data)

			* {{variável | number}} (transforma para número)

			* {{variável | currency}} (transforma para moeda)


	Aula 11.7. Passando parâmetros para pipes:

		- Site do Angular (https://angular.io/api?query=pipe) informa sobre os tipos de pipes e parâmetros que podem ser usados.

		- Exemplo : {{variável | date: 'dd/MM/y'}} (transforma para data com os parâmetros de formatação).

		- Pode ser utilizado a concatenação de pipes.


	Aula 11.8. Desafio - usando pipes:

		- No projeto do curso utilizar pipe para formatar as datas no lançamento pesquisa.



Módulo 12 Formulários e validação

	
	Aula 12.1. Introdução aos formulários:

		- A maioria das vezes os sistemas possuem vários formulários.

		- Formulário (action e method) envia dados  --> Servidor (recebe url ou no corpo da request), maneira tradicional.

		- Em angular o formulário representa um objeto javascript com varias propriedades, uma delas é 
		value com a estrutura (chave ,valor).

		- O formulário do angular idepende do servidor que vai receber este objeto.

		- No formulário deve existir a validação dos dados.

		- Formas de trabalhar com formulários Template-Driven Forms ou Reactive Froms (model-driven).


	Aula 12.2. Template-driven Forms: Criando um formulário;
	
		- Criar um projeto formulario $>ng new formulario.

		- Instalar o bootstrap no projeto $>npm install bootstrap --save

|------------------------------------------------------------------------------------------>[08/02/2019]

	Aula 12.3. Registrando os controles do formulário:

		- Utilizando a diretiva ngModel vinculando com o campo input do formulário.

		- Preciso definir a propriedade name que vincula o campo ao formulário.


	Aula 12.4. Adicionando opções dinâmicas no campo de seleção:

		-  Na tag select o valor pode vir de um objeto definido no componente.


	Aula 12.5. Definindo o valor padrão em campos com ngModel:

		- Alterações feitas no componente são refletidas no template(one way biding).


	Aula 12.6. Two-way binding com ngModel:

		- Alterações feitas no componente são refletidas no template e vice versa, componente ->template e template -> componente.
	
|------------------------------------------------------------------------------------------>[11/02/2019]

	Aula 12.7. Adicionando validação em formulários:

		- Primeiro podemos adicionar o atributo do html "required", que valida se o campo foi preenchido ou não.

		- Existe uma propriedade do formulário "valid" que identifica se o campo está valido ou não.

		- A validação no lado cliente melhora a experiência do usuário com o sistema. Mas é uma validação fraca.

		- Podemos desabilitar o botão que submete o formulário se ele não estiver valido.

		- O Angular já possui um conjunto de validadores.


	Aula 12.8. Exibindo erro de validação do formulário	:

		- Existe a propriedade do ngForm "invalid" tem valor contrário ao "valid".

		- Para desabilitar o autcomplete no html colocamos como "off".


	Aula 12.9. Exibindo erro de validação de controles do formulário:

		- Colocar o controle de validação em cada campo do formulário.

		- Para identificar a variável no campo do formulário, eu crio a variável de referência e instâncio com "ngModel".


	Aula 12.10. Rastreando o estado em controles do formulário:

		- Propriedades que permitem identificar se o campo foi tocado (touched) ou alterado (dirty).


|------------------------------------------------------------------------------------------>[18/02/2019]		

	Aula 12.11. Estilizando os campos inválidos com classes CSS do Angular:

		- Aplicar um estilo aos campos do componentes de acordo com a classe que o Angular designa.

		- Você pode conbinar várias classes Css é um componente.


	Aula 12.12. Estilizando os campos inválidos com Bootstrap:

		- Colocar classes do bootstrap com estilo.

		- Na aula é utilizado "has-danger" mas no bootstrap 4 substituir por "was-validated".

		- Na aula é utilizado class="form-control-feedback" mas no bootstrap 4 substituir por class="invalid-feedback" 


	Aula 12.13. Limpando formulários (reset):

		- Quando na página coloco a informação {{client | json}}, funciona com um debug para verificar o valor.

		- Usando "form.reset()", limpa os campos do formulários e os estados destes.


	

Módulo 13 - Páginas de cadastro


	Aula 13.1. Criando o protótipo do formulário de cadastro de lançamentos:

		- Na pasta do projeto executar o comando para criar o componente lançamentos:

			* "$>ng g c lancamento-cadastro --spec=false"

		- Na informação de grid da class, quando informo "ui-md-3" significa que em uma tela média ou superior ocupar 3 colunas. 	


|------------------------------------------------------------------------------------------>[20/02/2019]

	Aula 13.2. Adicionando seletor de data (componente Calendar):

		- Importa o componente "CalendarModule" do primeng, para ser utilizado no campo de data.

		- É preciso importar a dependência "BrowserAnimationsModule".

		- Utilizar a propriedade dateFormat="dd/mm/yy" para formatar a data no padrão Brasileiro.


	Aula 13.3. Adicionando botão de seleção:

		- Utilizar do PrimeNg o componente "<p-selectButton>".

		- Mudança dinâmica do label de acordo com a seleção do botão.


	Aula 13.4. Adicionando caixa de seleção (componente Dropdown):
	
		- Como estamos fazendo primeiro o protótipo vamos colocar valores fixos para categorias e pessoas.

		- Você pode modificar o estilo dos componentes do PrimeNg, identificando este e modificando no 
		arquivo css.
		
	
|------------------------------------------------------------------------------------------>[25/02/2019]

	Aula 13.5. Adicionando máscara de dinheiro com ng2-mask-money:

		- Para formatar campo de input com máscara monetária utilizar o componente ng2-currency-mask.

		- Para instalar "$>npm install ng2-currency-mask --save" vai adicionar a dependência no "package.json".

		- Adicionar os parâmetros para formatar o campo no padrão brasileiro:

				* [options]="{ prefix: 'R$ ', thousands: '.', decimal: ',' }"


	Aula 13.6. Desafio: criando o protótipo do formulário de cadastro de pessoa:

		- Na pasta do projeto executar o comando para criar o componente cadastro de pessoa.

			* "$>ng g c pessoa-cadastro --spec=false".

		- Seguir o mesmo exemplo feito para lançamento.	


	Aula 13.7. Adicionando campo com máscara (componente InputMask):

		- Vamos utilizar no campo de CEP.

	
	Aula 13.8. Validando controles de formulário com PrimeNG:

		- A propriedade "{{descricao.errors | json}}" exibe se o campo está inválido.


	Aula 13.9. Criando componente de mensagem de erro de validação:

		- Criar o componente sem template e css:

			* "$>ng g c message --spec=false --inline-template --inline-style"
		
		- Adicionando estilo ao componente:

			*  styles: [`
			    .ui-messages-error {
			      background-color: red;
			      color: white;
			      font-weight: bold;
			      margin: 0;
			      margin-top: 5px;
			    }
			  `]

|------------------------------------------------------------------------------------------>[28/02/2019]

	Aula 13.10. Desafio: controles, validações e mensagens de erro:

		- Adicionar o NgModel, validadores e mensagem em cadastro de pessoa e lançamentos.

		- Feito


	Aula 13.11. Desafio: criando mais componentes

		- Criar um componente de vai substituir a tabela dos lançamentos na página de pesquisa lançamentos.
	 
	 	- Criar um componente de vai substituir a tabela das lançamentos na página de pesquisa pessoas.

	 	- Feito


Módulos 14 - Módulos do Angular:


	Aula 14.1. Introdução aos módulos:

		- Toda aplicação Angular tem um módulo raiz que geralmente é chamado appmodule.

		- Criar módulos para organizar o projeto. Cada módulo agrega componentes, diretivas e pipe.

		- Um módulo deve declarar que possui componentes, diretivas e pipe.

		- Componentes que não forem exportados somente podem ser utilizados apenas pelo próprio módulo.


	Aula 14.2. Criando um módulo e exportando um componente	:

		- Para criar um módulo usando AngularCLI "$>ng g m botoes"

		- Criar um componente dentro do módulo criado "$>ng g c botoes/botao-grande"


|------------------------------------------------------------------------------------------>[01/03/2019]


	Aula 14.3. Reexportando um módulo:

		- O AppModule importa o módulo do componente e este exporta o seu componente.

		- Um módulo pode importar outro módulo.


	Aula 14.4. Criando um componente interno do módulo:

		- Um componente encapsulado só pode ser usado dentro do módulo.


	Aula 14.5. O que são Feature Modules (módulos de funcionalidades) ?

		- As aplicações geralmente possuem conjunto de funcionalidades.

		- AppModule(MessageComponent, NavbarComponent, AppComponent): 

			* Pessoas(PessoaCadastroComponent, PessoaGridComponent, PessoaPesquisaComponent) 

			* Lançamentos(LancamentosPessoaCadastroComponent, LancamentosGridComponent, LancamentosPesquisaComponent)


	Aula 14.6. Criando um Feature Module:

		- Criar o módulo lancamentos "$>ng g m lancamentos" que cria um pasta "\lancamentos", mover os componentes de lançamentos
		para a pasta, ajustar as importações no "lancamentos.module.ts".

		
|------------------------------------------------------------------------------------------>[07/03/2019]

	Aula 14.7. Desafio: criando o feature module de pessoas [ok] :

		- Criar o módulo pessoas "$>ng g m pessoas" que cria um pasta "\pessoas", mover os componentes de pessoas
		para a pasta, ajustar as importações no "pessoas.module.ts".

	Aula 14.8. O que são Shared Modules?

		- Um componente compartilhado entre outros componentes.

		- SharedModule um módulo compartilhado.


	Aula 14.9. Criando um Shared Module:

		- Criar o modulo "$>ng g m shared".

		- Importar o "ShareModule" nos componentes Lançamentos e Pessoas.


	Aula 14.10. O que é Core Module?

		- Componentes que são utilizados apenas pelo "AppComponent", devem ser definidos em um "CoreModule".


	Aula 14.11. Desafio: criando o Core Module [ok]:

		- Criar o módulo "core"	"$>ng g m core".

		- Mover o componente "navbar" para o "core".

		- Declarar o "navbar" no módulo "core".

		- Retirar a referência "NavbarComponent" do app.module.ts e importar o "CoreModule".



Módulo 15 - Serviços e injeção de dependências:

	
	Aula 15.1. Introdução aos serviços:

		- Quando uma funcionalidade precisa ser disponibilizadas para vários componentes ou módulos.

		- Um serviço tem como foco as regras da aplicação.

		- Evita duplicação de código, reaproveitamento e melhora a manutenção.

|------------------------------------------------------------------------------------------>[11/03/2019]

	Aula 15.2. Implementando um serviço: 

		- Utilizar um exemplo para entender sobre serviço.

		- No exemplo "projetoteste", implementar em "funcionario-form" a chamada de um serviço.

		- Regras do negócio não devem ser colocados no componente e sim em uma classe service, pois a principal responsabilidade
		do componente é controlar a view ( interface com usuário).


	Aula 15.3. O que é injeção de dependências?	

		- DI (dependency injection) um padrão de projeto implementado pelo Angular.

		- Com um dos objetivos de diminuir a quantidade de informações, que um componente precisa saber sobre sua dependência.

		- É preciso prover a classe que eu quero injetar, através do "providers:[]" no "app.module.ts".

		obs: O VScode estava exibindo um warning nas classe Type Script, solução: In VSCode, Go to File => Preferences => Settings (or
		Control+comma) and it will open the User Settings file. Add "javascript.implicitProjectConfig.experimentalDecorators": true to 
		the file and it should fix it. It did for me.


	Aula 15.4. Configurando o injetor com provider por classe:

		- Posso prover outra classe que extende FuncionarioService.

		- Apenas com mudança de configuração consigo alterar o comportamento do sistema, sem a necessidade de alterar o que já foi
		implementado. Tenho um ganho com a flexibilização deste.

		- Uma implementação mais flexível me permiter modificar o sistema sem impactar nas classes já testadas e em produção. Sendo
		necessário apenas testar as novas classes.


|------------------------------------------------------------------------------------------>[14/03/2019]

	
	Aula 15.5. Configurando o injetor com provider por fábrica:

		- Cria um método que vai referênciar um provider por fábrica.


	Aula 15.6. Configurando o injetor com provider por valor e o decorator @Inject:

	
	Aula 15.7. Injetando serviços dentro de serviços e o decorador @Injectable:

	

|------------------------------------------------------------------------------------------>[15/03/2019]


	Aula 15.7. Injetando serviços dentro de serviços e o decorador @Injectable:

		- Através do construtor de um serviço injetar outro serviço.

		- Uma classe para utilizar injeção de dependência precisa ter o decorate "@Injectable" definido nela.

		- O decorate "@Injectable", pode ser colocado em todas as classes de serviço por padrão.


	Aula 15.8. Como funciona o Injetor Hierárquico:

		- O injetor do Angular retorna um Sigleton (uma mesma instância para todos).

		- Vai exitir um Injetor raiz e Injetor filho.

		- Quando injetamos um provedor no componente ele também é utilizado pelos filhos do componente.


Módulo 16 - Requisições HTTP:


	Aula 16.1. Por que precisamos de requisições HTTP?

		- SPA (aplicações com uma única página) se comunicam com Back-end um servidor HTTP (fornce uma API REST).


	Aula 16.2. Instalando e testando o json-server:

		- O json-server simula um Back-end para testar as requsições REST. É uma API REST fake, usada para testes.

		- Site https://github.com/typicode/json-server

		- Instalação "$>npm install -g json-server"

		- Para iniciar API REST fake "$>json-server --watch data/db.json"

		- Utilizar o PostMan para realizar as requisições API REST. 


	Aula 16.3. Fazendo requisição com GET e recebendo o retorno:

		- Criar um service de cidades, que vai responder um get com retorno de um método.


|------------------------------------------------------------------------------------------>[19/03/2019]

	
	Aula 16.4. Fazendo requisição com POST:

		- Utilizado para inserir dado.


	Aula 16.5. Fazendo requisição com DELETE:

		- Utilizado para excluir dado.


	Aula 16.6. Fazendo requisição com PUT:

		- Utilizado para alterar dado.
	

	Aula 16.7. Tratando erros de requisições HTTP:

		- Captura erro do método ".catch(erro => {.... return Promise.reject(`Erro ao alterar cidade `) })".

		- Simular algum erro para utilizar o tratamento.



Módulo 17 -Implementando os serviços do projeto:

	
	Aula 17.1. Revisando e iniciando o back-end do projeto do curso:

		- Integração com o Back-end do projeto. 


|------------------------------------------------------------------------------------------>[25/03/2019]

		- Gerar novamente o jar:

			# Como aplicação estava apontando para produção no heroku, precisa comentar dois parâmetros do application-prod.properties
			que habilitam o https para true e a url do heroku.

			# Caso queria pular estes testes e simplesmente gerar o JAR, selecione Run As > Maven Build… (com os três pontos no fim)
			Você ira ter uma nova tela. No campo com o nome Goals, coloque o seguinte comando: clean install -DskipTests

			# Como temos arquivos de migração do flyway é necessário apagar as tabelas para serem geradas novamente.

			# O arquivo é gerado em "/home/lincolnjohn/Desenvolvimento/AlgaWorks/Fullstack-Angular-Spring/Projeto/fullstackAngularSpring/
			algamoney-api/target/algamoney-api-1.0.0-SNAPSHOT.jar".

			# Executar o jar gerado "$>java -jar algamoney-api-1.0.0-SNAPSHOT.jar --spring.datasource.username=root
			--spring.datasource.password=admin --spring.profiles.active=basic-security"

			# Para testar no Postman:

				- No Authorization type: No Auth
				- Headers key: Authorization Basic (encode do usuário:senha)
				- Site para encode64 https://www.base64encode.org/

		- Verificar Aula 7.2. Profiles do Spring, para configura ambiente de produção ou desenvolvimento.



|------------------------------------------------------------------------------------------>[26/03/2019]

	Aula 17.2. Criando o serviço de consulta de lançamentos:

		- Vamos implementar o serviço utilizando a API já desenvolvida, usando uma chamada Http.

		- Criar uma classe de serviço "$>ng g s lancamentos/lancamento --spec=false".

		- Uando HttpClient pela versão do Angular 6.

		- Quando do levantamento do servidor back-end é necessário informar o parâmetro para ele permitir acesso apartir do front-end
		Angular "$>java -jar algamoney-api-1.0.0-SNAPSHOT.jar --spring.datasource.username=root --spring.datasource.password=admin --spring.profiles.active=basic-security --algamoney.origin-permitida=http://localhost:4200".


|------------------------------------------------------------------------------------------>[29/03/2019]

	Aula 17.3. Adicionando filtro por descrição na pesquisa de lançamentos:
	
		- Retirar o componente lancamento-grid.component é colocar o código direto na página lancamento-pesquisa.component.

		- O método pesquisar ficou diferente devido nova versão do angular:

			 pesquisar(filtro: LancamentoFiltro): Promise<any> {

    		const params = filtro.descricao ? new HttpParams().set('descricao', filtro.descricao) : { }

			    const headers = new HttpHeaders().set('Authorization', 'Basic YWRtaW5AYWxnYW1vbmV5LmNvbTphZG1pbg==');

			    return this.http.get(`${this.lacamentosUrl}?resumo`,  {headers, params} )
			      .toPromise();
			      /*.then(response => {
			        console.log(response);

			      });*/
			  }

|------------------------------------------------------------------------------------------>[01/04/2019]

	Aula 17.4. Adicionando filtro por datas na pesquisa de lançamentos:

		- Fazendo testes na API com Postman.

		- Instalar a biblioteca Moment.js, que converte string em data no javaScript(http://momentjs.com/):

			* "$>npm install moment --save" 

		- O componente "p-table" do primeng não possui o parâmetro emptyMessage="Nenhum lançamento encontrado", substituir:
		
		 	<div *ngIf="lancamentos.length==0">
                <span style="font-weight: bold"> Nenhum Lançamento encontrado </span>
            </div>  	


    Aula 17.5. Implementando a paginação no serviço de lançamentos:

    	- API já foi implementada para executar a paginação do sistema, quando for solicitada uma consulta.

    	- Usando postman posso passar parâmetros de paginação para API, como exemplo "page" e "size" que respectivamente identificam
    	a página que vai ser exibida e quantos registros por páginas.

    	- Na classe "LancamentoFiltro" adicionar as propriedades "page" e "size".


    Aula 17.6. Configurando a paginação lazy do PrimeNG:

    	- Por padrão o componente do Primeng faz a paginação no lado cliente (browse), que não é aconselhado a realizar quando
    	temos um número grande de registro.

    	- A implementação que vamos fazer controla está paginação, realizando por demanda (Lazy). Somente quando o cliente solicitar
    	uma nova página o sistema faz a consulta desta, substituindo atual pela nova.

    	- Utilizar uma paginação eficiênte para uma quantidade grande de dados, diminuindo a quantidade de banda e deixando aplicação
    	mais leve.

    	- Para utilizar a versão mais nova primeng e angular, consultei Aula 25.12

|------------------------------------------------------------------------------------------>[02/04/2019]

	Aula 17.7. Desafio: criando a consulta e listagem de pessoas:

		- "pesquisar(pagina=0)" significa que o método pesquisar recebe o parâmetro "pagina". Mas note que o parâmetro já está recebendo
		um valor, que é o zero "pagina = 0". Chamamos isso de Default-initialized parameters, ou seja, definimos um valor padrão de
		inicialização para o parâmetro. Neste caso se chamarmos a função "pesquisar()" sem nenhum parâmetro o valor da variável "pagina" será
		zero, caso a gente passe algum parâmetro, o valor passado é o que será o valor da variável "pagina".

		- O valor entre os acentos graves ``, representam as Template Strings. Isso É algo definido no Javascript, logo, o Typescript 
		herdou esta funcionalidade. O Template String permite que coloquemos variáveis ou expressões que retornem String juntamente 
		com a String escrita (hard code), exemplo: `texto string ${expression} texto string` Neste caso teríamos uma String e o valor 
		da variável ou expressão ${expression} será adicionado na String final. De forma similar, sem utilizar Template String, faríamos 
		assim: "texto string " + expression + " texto string". O resultado dos dois trechos de código são equivalentes, mas a utilização 
		de Template String são mais elegantes, de fácil legibilidade e nos dá mais possibilidades.

		
|------------------------------------------------------------------------------------------>[15/04/2019]

	
	Aula 17.7. Desafio: criando a consulta e listagem de pessoas: [ ok ]

		- Similar a Lançamento, implementar filtro para buscar por nome, paginação lazy e implementar um método listarTodas que 
		vai ser utilizada em um combo-box.

	
	Aula 17.8. Excluindo lançamentos e o decorador @ViewChild:

		- Como ação apos exclusão de acordo com fórum implementei "this.pesquisar(this.filtro.pagina);"
	 	

	Aula 17.9. Adicionando mensagem de sucesso com Angular Toasty(este componente somente funciona até o Angular4) :

		- Componente do Angular https://github.com/akserg/ng2-toasty:

			* npm install ng2-toasty --save .

			* Adicionar o css do ng2-toasty em ".angular-cli.json".

		- O componete que substitui este é https://github.com/emonney/ngx-toasta
		
		- Vou adotar toast do primeng.


|------------------------------------------------------------------------------------------>[22/04/2019]

	
	Aula 17.10. Adicionando diálogo de confirmação antes da exclusão:

		- Utilizar o componente do primeeng "<p-confirmDialog>", para exibir um dialogo de confirmação da exclusão.

		- Utilizar a bliblioteca de icones do primeng "PrimeIcons".


	Aula 17.11. Alterando o locale da aplicação para pt-BR:

		- O exemplo da aula não funcionou para a nova versão do Angular, na documentação 
		https://angular.io/guide/i18n#setting-up-the-locale-of-your-app :

			* Arquivo app.modules.ts

			* 	import { registerLocaleData } from '@angular/common';
				import localePt from '@angular/common/locales/pt';
				import { LOCALE_ID } from '@angular/core';

				registerLocaleData(localePt);

				@NgModule({.....})
				 providers: [
				    ......
				   {provide: LOCALE_ID, useValue: 'pt-BR'}

				  ],


	Aula 17.12. Criando um serviço de tratamento de erros:

		- Comando para criar serviço $>ng g s core/error-handler --skipTests .

		- Pelas boas práticas apenas o app.modules import o core.modules .

		- Como estou usando "Toast" do PrimeNg a implementação da mensagem de erro ficou diferente do exemplo.


|------------------------------------------------------------------------------------------>[29/04/2019]

	Aula 17.13. Desafio: implementando a exclusão de pessoas :[ok]

		- As pessoas que possuem vinculo com lançamento não podem ser excluidas, vai dar uma mensagem de erro de 
		"Operação não permitida". Para testarmos precisamos primeiro excluir o lançamento e depois a pessoa.

		- Implementar a exclusão de forma semelhante ao lançamento.


	Aula 17.14. Desafio: mensagem de erro de usuário na exclusão de pessoa: [ok]
	
		- Quando API retorna um erro da classe 4xxx (400, 401, 404...), significa que o cliente erro alguma informação na passagem 
		da requisição.

		- A API retorna erro "400 bad request" , quando tentamos deletar um usuário que tem lançamento vinculado a ele
		um erro de banco de dados "ConstraintViolation".

		- A API retorna erro "404 not found", recurso nã encontrado tentamos deletar um usuário que não existe.

		- Implementei o desafio utilizando HttpErrorResponse.


	Aula 17.15. Desafio: implementando a mudança de status de pessoas: [ok]

		- Fiz alterações na solução para se adaptar a nova versão do Angular.


	Aula 17.16. Desafio: implementando o serviço de listagem de categorias: [ok]

		- Criar a classe service de categorias utilizando o Angular CLI $>ng g s categorias/categoria --skipTestes=false


|------------------------------------------------------------------------------------------>[02/05/2019]

	
	Aula 17.17. Listando as categorias cadastradas no dropdown:

		- É preciso fazer uma conversão do array que se recebe do categoriaService para o padrão do PrimeNg.


	Aula 17.18. Desafio: listando as pessoas cadastradas no dropdown [ok]
	
		- O método "listarTodas()" do categoria.service retorna um array com os dados que vieram no arquivo json, mas no caso de 
		listar todas as pessoas do pessoa.service, foi utilizado paginação e os dados das pessoas no arquivo json vieram dentro de um 
		array chamado "content", por isso foi utilizado response.content (fórum do curso).


	Aula 17.19. Criando classes de modelo e usando no cadastro de lançamentos:

		- O back-end já está habilitado para receber uma cadastro de lançamento.

		- Preciso implementar no front-end o método para salvar lançamento.

		- Fazer o bind entre as propriedades do lançamento component e o lançamento html.

		- Criar uma classe de modelo que representa um Lançamento.

		- Estava dando erro na inclusão de Lançamento:

			* Mensagem de não autorizado, rodando no back-end a mensagem erá de que não existia ou inativa.

			* Alterei a classe LancamentoService.validarPessoa(), gerei novamente o jar e o sistema funcionou.

			* JSON para incluir Lancamento:
				Body:
					
					{
					    "codigo": 16,
					    "descricao": "Aluguel de carro",
					    "dataVencimento": "2017-07-15",
					    "dataPagamento": "2017-07-11",
					    "valor": 159,
					    "observacao": "Ford ka",
					    "tipo": "RECEITA",
					    "pessoa": {
					        "codigo": 2,
					        "nome": null,
					        "ativo": null,
					        "endereco": null
					    },
					    "categoria": {
					        "codigo": 1,
					        "nome": null
					    }
					}

			* Authorization: Type: Basic Auth, Username: admin@algamoney.com Password:admin	
			
			* Headers: Authorization: Basic YWRtaW5AYWxnYW1vbmV5LmNvbTphZG1pbg== ,  Content-Type: application/json



|------------------------------------------------------------------------------------------>[08/05/2019]


	Aula 17.21. Desafio: implementando o cadastro de pessoas: 

		- Similar ao Cadastro de Lançamento.



|------------------------------------------------------------------------------------------>[23/05/2019]

	Aula 17.21. Desafio: implementando o cadastro de pessoas: (continuação) [ok]

	- Como estou usando Angular 7 tive que pesquisar como fazer uma requisição "POST", que ficou diferente do exemplo da aula:

	 adicionar(pessoa: Pessoa): Promise<Pessoa> {
	      const httpOptions = {
	      headers: new HttpHeaders({
	        'Content-Type':  'application/json',
	        'Authorization': 'Basic YWRtaW5AYWxnYW1vbmV5LmNvbTphZG1pbg=='
		      })
		    };
	    return this.http.post<Pessoa>(this.pessoasUrl, pessoa, httpOptions)
	    .toPromise();
	  }

	- Exemplo de inclusão via PostMan:

		Content-Type: application/json,
	    Authorization: Basic YWRtaW5AYWxnYW1vbmV5LmNvbTphZG1pbg==

		body: http://localhost:8080/pessoas/{
				"endereco":{
					"logradouro":"teste",
					"numero":"3333",
					"complemento":"teste",
					"bairro":"teste",
					"cep":"44.444-444",
					"cidade":"teste",
					"estado":"te"
					},
				"ativo":true,
				"nome":"teste"
			}


Módulo 18 -Roteamento e Navegação:


	Aula 18.1 Introdução a rotas:

		- Permite navegar no sistema através de rotas.

		- Configurar no projeto as rotas através das urls.


	Aula 18.2. Configurando rotas na aplicação:

		- No app.module.ts (módulo raiz) configurar as rotas.

		- Utilizar um componente do Angular <router-outlet></router-outlet>, que chama as rotas definidas de acordo com a url
		digitada.


	Aula 18.3. Navegando com Router Link:
	
		- Temos que evitar que a cada request a aplicação seja carregada.

		- Para evitar esse recarregamento na navegação da aplicação utilizar uma diretiva do Angular "routerLink". Que faz apenas
		a request da url solicitada, evitando o recarregamento da página inteira.

		- Todo componemte que for utilizar o Router Link precisa importar o "RouterModule".
	


|------------------------------------------------------------------------------------------>[03/06/2019]

	
	Aula 18.4. Estilizando links da rota ativa:

		- Aplicação do css feita de forma dinâmica, na rota atual utilizando routerLinkActive="ativo".


	Aula 18.5. Recebendo parâmetros da rota:

		- Criar uma rota parametrizada, usando token.

		- Implementar o botão de editar na pesquisa lançamento.


	Aula 18.6. Desafio: implementando os serviços de atualização e busca por código:
	
		- Para atualizar utilizar o método PUT do Http.

		- Quando for atualizar tem que converte de string para Date, utilizar a biblioteca javaScript(http://momentjs.com/).

		- A data de pagamento pode está nula, então é necessário testar antes de fazer o parser.

		- Criar em lancamento.service.ts os métodos atualizar, buscarPorCodigo e converterStringParaDatas.
 

 	Aula 18.7. Preenchendo os campos na edição de lançamentos:

 		- Implementar método para carregar o Lançamento selecionado.



|------------------------------------------------------------------------------------------>[04/06/2019]
		

	Aula 18.8. Salvando lançamentos editados:

		- Implementar método que identifica se é uma atualização ou um novo Lançamento.

		- Corrigir o campo "Observacao", não estava associada (binding) com objeto Lançamento.


	Aula 18.9. Implementando navegação imperativa:

		- Navegação programada, depois de realizar algumas tarefas rotear para determinada página.

		- Quando mudamos de rota o componente é instanciado novamente. Ele perde parâmetros de valores
		iniciais.

		



 







Nome:	DANIEL MOURA PEREIRA
Login:	scorpion
Unidade:	SECRETARIA GERAL

ramal 8813, 7115, 7114, 7116







